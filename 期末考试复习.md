## 考试范围
考试只考察教材中的第七章之后的部分，并且考察形式为上机考，应该是给好项目的骨架并且创建好java文件，让我们编写缺少的部分，暂时不确定会不会写配置（类似mybatis、spring的.xml文件）

## 第八章mybatis

### mybatis最基本使用方法
1. 创建数据库连接配置文件
db.properties:
```
driver = com.mysql.cj.jdbc.Driver
url = jdbc:mysql://localhost:3306/db_name
username = root
password = 1234
```

2. 创建Mybatis配置文件
mybatis-config.xml(放到src/main/resources/下):
```xml
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"  "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <properties resource="db.properties" />

    <settings>
        <setting name="lazyLoadingEnabled" value="true" />
        <setting name="aggressiveLazyLoading" value="false" />
        <setting name="logImpl" value="STDOUT_LOGGING" />
    </settings>

    <environments default="mysql">
        <environment id="mysql">
            <transactionManager type="JDBC" />
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}" />
                <property name="url" value="${jdbc.url}" />
                <property name="username" value="${jdbc.username}" />
                <property name="password" value="${jdbc.password}" />
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <mapper resource="mapper/CustomerMapper.xml"></mapper>
    </mappers>
</configuration>
```

3. 创建对应数据表的实体类(大驼峰命名) 和Dao层接口

4. 创建映射文件:
xxxMapper.xml:
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.mapper.ExampleMapper">
    <!-- Example: Select all records from a table -->
    <select id="selectAllExamples" resultType="com.example.model.Example">
        SELECT id, name, description
        FROM example_table
    </select>
    <!-- Example: Select a record by ID -->
    <select id="selectExampleById" parameterType="java.lang.Long" resultType="com.example.model.Example">
        SELECT id, name, description
        FROM example_table
        WHERE id = #{id}
    </select>
    <!-- Example: Insert a new record -->
    <insert id="insertExample" parameterType="com.example.model.Example" useGeneratedKeys="true" keyProperty="id">
        INSERT INTO example_table (name, description)
        VALUES (#{name}, #{description})
    </insert>
    <!-- Example: Update an existing record -->
    <update id="updateExample" parameterType="com.example.model.Example">
        UPDATE example_table
        SET name = #{name},
            description = #{description}
        WHERE id = #{id}
    </update>
    <!-- Example: Delete a record by ID -->
    <delete id="deleteExampleById" parameterType="java.lang.Long">
        DELETE FROM example_table
        WHERE id = #{id}
    </delete>

</mapper>
```

5. 在mybatis-config.xml中配置写好的映射文件
```xml
<mappers> 
<mapper resources="com/example/mybatis/mapper/xxxMapper.xml"/>
</mappers>
```

6. 测试类中测试
```java
InputStream is = Resource.getResourceAsStream("mybatis-config.xml"); // 读取配置文件
SqlSessionFactory sf = new SqlSessionFactoryBuilder().build(is);  // 创建会话工厂
SqlSession session = sf.openSession();  // 获取会话对象
List<Example> examples = session.selectAllExamples();  // 调用在xxxmapper.xml文件中设置的方法
session.close(); // 关闭
is.close(); // 关闭
```

### 一对一查询

一对一查询类似于：查询某个人身份证+学生证上的所有信息

假设已经创建好了team表和address表，要实现联合查询
1. 定义实体类
```java
public class Address{
    private Integer id;
    private String city;
    private String country;
    // 别忘了使用ctrl+shift+s生产getter和setter方法
}

public class Team {
    private Integer id;
    private String name;
    private String coach;
    private String stadium;
    private Address address; // Team的一个属性是别的实体类
    // getter setter
}
```

2. 创建Dao层接口
```java
public interface TeamDao {
  public Team getTeamWithAddress(Integer id);
}

```
3. 创建映射文件
    *重点* TeamMapper.xml:

```xml
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.mapper.TeamDao">
  <select id="getTeamWithAddress" parameterType="java.lang.Integer" 
            resultType="TeamWithAddressResult">
    select t.id, t.name, t.coach, t.stadium, a.id as aid, a.city, a.country
    from tb_team t, tb_address address
    where t.address_id = a.id;
  </select>
  <resultMap type="team" id="TeamWithAddressResult">
    <id property="id" column="id" />
    <result property="name" column="name"></result>
    <result property="coach" column="coach"></result>
    <result property="stadium" column="stadium"></result>
    <association property="address" javaType="address">
      <id property="id" column="aid"></id>
      <result property="city" column="city"></result>
      <result property="country" column="country"></result>
    </association>
  </resultMap>
</mapper>
```



4. 编写测试类
```java
@Test 
public void findTeamWithAddressTest(){
  SqlSession session = sf.openSession();
  Team team = session.selectOne("con.example.mybatis.mapper.TeamDao.getTeamWithAddress",1);
  System.out.println(team); session.close();
}
```



### 一对多查询

一对多查询类似于：查询某个球队信息+旗下所有球员的信息   查询到的结果中某一项是一个集合

使用嵌套结果的方法进行查询, 实体类、接口类见书本page137

```xml
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.mapper.DeptDao">
  <select id="getDeptWithStudentList" resultType="DeptWithStudentResult">
    select d.id, d.name, d.facuty, d.intro, s.id as sid, s.name as sname,s.gender
    from tb_dept d, tb_student s
    where s.deptId = d.id;
    and d.id = #{id}
  </select>
  <resultMap type="dept" id="DeptWithStudentResult">
    <id property="id" column="id" />
    <result property="name" column="name"></result>
    <result property="facuty" column="facuty"></result>
    <result property="intro" column="intro"></result>
    <collection property="stuList" javaType="student">
      <id property="id" column="sid"></id>
      <result property="name" column="sname"></result>
      <result property="gender" column="gender"></result>
    </collection>
  </resultMap>
</mapper>
```


### 一对多查询
page 140


## 第十章 Spring IoC 
Spring的核心就是项目启动是初始化一个Map,并在其中初始化需要用到的所有对象，需要使用的时候从map中把对象取出来使用，这种思想叫做控制反转*即将创建对象的任务交给spring容器去做* 在spring当中实现控制反转的方式是依赖注入（即将需要用到的对象通过属性的方式注入给调用这个对象的对象）

### 使用xml文件配置bean 并使用spring创建对象
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	https://www.springframework.org/schema/beans/spring-beans.xsd">
	<!-- 1. Mobile (无参构造器 + Setter 注入) -->
	<bean id="mobile" class="com.example.soft.spring.dao.impl.Mobile">
		<property name="number" value="13900001111"/>
		<property name="version" value="iOS 19"/>
	</bean>
	<!-- 2. Computer (有参构造器注入) -->
	<bean id="computer" class="com.example.soft.spring.dao.impl.Computer">
		<constructor-arg name="cpu" value="Intel i9"/>
		<constructor-arg name="memory" value="32GB DDR5"/>
	</bean>
	<!-- 3. Printer (实例工厂方法实例化) -->
	<bean id="printerFactory" class="com.example.soft.spring.dao.impl.PrinterFactory"/>
	<bean id="printer" factory-bean="printerFactory" factory-method="getPrinter">
		<property name="type" value="Laser"/>
		<property name="price" value="500"/>
	</bean>
	<!-- 4. Washer (静态工厂方法实例化) -->
	<bean id="washer" class="com.example.soft.spring.dao.impl.Washer" factory-method="getWasher">
		<property name="type" value="Drum"/>
		<property name="price" value="3500"/>
	</bean>
</beans>
```

```java
    ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
		Machine mobile = ac.getBean("mobile", Machine.class);
```

### 使用java代码配置bean
首先使用@Configuration放在配置类上，在配置类中使用@Bean注解装饰返回对象的方法
```java
@Configuration 
public class PersonConfig{
  @Bean 
  public Person chinese() { return new Chinese(); }
}
```

使用AnnotationConfigApplicationContext来创建bean:
```java
ApplicationContext context = new AnnotationConfigApplicationContext(PersonConfig.class)
Chinese ch = context.getBean("chinese", Chinese.class);
```

### 使用纯注解配置
首先创建配置类 使用@ComponentScan("com.xxx.xxx") 配置需要扫描的包
```java
@ComponentScan("com.example.spring.anno.bean")
public class PersonConfig{}
```

接着在这个包下的类中使用@Component注解指定Bean
```java
@Component 
public class Chinese{
  ...
}
```

实例化:
```java
同上 
```

### Bean的组件装配
组件装配就是把spring容器中的一个bean作为另一个bean的属性装配上去
* 基于xml的装配
```xml
<beans>
  <bean id="dept" class="com.example.spring.di.bean.Dept"></bean>
  <bean id="stagff" class="com.example.spring.di.bean.Staff">
    <property name="dept" ref="dept"/>
  </bean>
</beans>
```

* 使用Java代码装配

创建一个配置类，将用到的Bean提前创建好，并打上@Bean注解

```java
@Configuration
public class AnnotationCOnfig{
    @Bean
    public TeamDao teamDao(){ return new TeamDaoImpl(); }   
    @Bean
    public TeamService teamService(){ return new TeamServiceImpl(); }
    ...
}
```

* 自动装配

使用@Component、@Service、@Reposity装饰Bean,并使用@AutoWired、@Resource依赖注入



## 第11章 SpringAOP

AOP的重点在于切点和切面

### 使用xml方式配置Aop、切点、前置、后置通知

```java
public class Doctor implements Human{
    public void sleep() {
        System.out.println("Doctor正在睡觉...");
    }
    public void bath() {
        System.out.println("Doctor正在洗澡...");
    }
}
```

```java
public class MyXmlAspect {
    // 前置增强方法
    public void takeOffCloth() {
        System.out.println("脱衣服 (XML前置通知)");
    }
    // 后置增强方法
    public void putOnCloth() {
        System.out.println("穿衣服 (XML后置通知)");
    }
}
```
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/aop
           http://www.springframework.org/schema/aop/spring-aop.xsd">
    <bean id="doctorBean" class="cn.edu.sdju.soft.aop.impl.Doctor" />
    <bean id="policeBean" class="cn.edu.sdju.soft.aop.impl.Police" />
    <bean id="myAspect" class="cn.edu.sdju.soft.aop.MyXmlAspect" />
    <aop:config>
        <aop:aspect ref="myAspect">
            <aop:pointcut expression="execution(* cn.edu.sdju.soft.aop.impl.*.*(..))" id="myPointcut"/>
            <aop:before method="takeOffCloth" pointcut-ref="myPointcut" />
            <aop:after-returning method="putOnCloth" pointcut-ref="myPointcut" />
        </aop:aspect>
    </aop:config>
</beans>
```

### 使用注解方式配置

```java
@Repository
public class Doctor implements Human{
	... 同上 ...
}
```

```java
@Aspect
@Component
public class MyAop{
    // 配置切入点 下面这个表达式表示impl包下所有bean的所有方法
    @Pointcut("execution(* cn.edu.sdju.soft.aop.impl.*.*(..))")
    void aPoint() {}
    
    @Before("aPoint()") // 前置增强方法
    public void takeOffCloth() {
        System.out.println("脱衣服 (注解前置通知)");
    }
    @AfterReturning(value = "aPoint()") // 后置增强方法
    public void putOnCloth() {
        System.out.println("穿衣服 (注解后置通知)");
    }
}
```

